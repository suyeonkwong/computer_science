**동시성에 영향을 미치는 잠금과 트랜잭션, 트랜잭션 격리 수준**

## 트랜잭션

트랜잭션은 작업의 완전성을 보장해주는 것으로, 논리적인 작업 셋 자체가 모두 적용되거나 아무것도 적용되지 않아야 함을 보장 해주는 것이다. 

InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원 상태르 만드는 트랜잭션을 보장한다. 트랜잭션을 보장하지 않는 다른 스토리지 엔진은 작업의 일부분만 적용되는 부분 업데이트 현상이 발생할 수 있어 데이터의 정합성을 보장하기 힘들다.  

## MySQL 엔진의 잠금

잠금은 크게 스토리지 엔진 레벨과 MySQL엔진 레벨로 나뉜다. 

### 글로벌 락

잠금 가운데 범위가 가장 크며 영향을 미치는 범위가 서버 전체이다. 

### 테이블 락

명시적으로 또는 묵시적으로 특정 테이블에 대한 락을 획득할 수 있다. 명시적 락과 다르게 묵시적인 테이블 락은 MyISAM이나 MEMORY테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다. InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않는다. InnoDB의 테이블도 대부분의 데이터 변경 쿼리는 무시되고, 스키마를 변경하는 DDL의 경우에 영향을 미친다.

### 네임드 락

네임드 락은 GET_LOCK()함수를 통해 데이터베이스의 객체가 아닌 임의의 문자열에 대해 잠금을 설정할 수 있다. 

### 메타데이터 락

테이블의 이름이나 구조를 변경하는 경우 자동으로 획득하는 잠금이다.  

## InnoDB 스토리지 엔진의 잠금

### **레코드 락**

레코드 자체만 잠그는 것. InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다. 인덱스가 하나도 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다. 

- 인덱스를 잘 설계해야 하는 이유 : 조건에 맞는 인덱스가 없다면 UPDATE 해야하는 레코드 때문에 불필요한 부분까지 잠긴 레코드가 되므로 각 클라이언트 간의 동시성이 상당히 떨어진다.

### **갭 락**

다른 DBMS와 다르게 갭 락은 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락이 존재한다. 갭 락의 역할은 레코드 간격 사이에 새로운 레코드가 INSERT되는 것을 제어하는 것이다. 

### **넥스트 키 락**

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다. InnoDB의 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 역할을 한다. 그러나 넥스트 키 락과 갭 락으로인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다. 

- Deadlock : 두 transaction이 각각 lock을 설정하고, unlock하지 않은 상태에서 서로의 lock이 걸린 데이터에 접근하려고 할 때, 서로 대기를 계속하여 영원히 처리되지 않는 상황

### **자동 증가 락**

AUTO_INCREMENT 컬럼이 사용된 테이블에 동시에 여러 레코드가 INSERT될 때 사용되는 테이블 수준의 잠금이다. 이 락은 아주 짧은 시간 동안 걸렸다가 해제되는 잠금이라서 대부분 문제가 되지 않는다. 

## MySQL의 격리 수준

트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지 결정하는 기능이다. 

격리 수준엔 크게 4가지 단계가 있고, 뒤로 갈수록 트랜잭션의 데이터 격리 정도가 높아지며, 동시처리 성능이 떨어진다. 

### READ UNCOMMITED

각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK여부의 상관없이 다른 트랜잭션에서 보여진다. 이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 **더티 리드**라고 한다. 해당 격리 수준에서 더티리드를 허용하므로 데이터가 나타났다가 사라졌다 하는 현상을 초래할 수 있다. 

### READ COMMITED

COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회 할 수 있으므로 이 레벨에선 더티 리드 현상은 발생하지 않는다. 

COMMIT되지 않은 데이터는 변경 전 데이터인 언두로그를 통해 조회한다. 그러나 하나의 트랜잭션 내에서 똑같은 SELECT쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 **REPEATABLE RAED가 보장되지 않는**다.  

### REPEATABLE READ

InnoDB 스토리지 엔진의 기본 격리 수준으로 언두 공간에 값을 백업해두고 실제 레코드 값을 변경하는 MVCC방식을 사용한다는 점에서 READ COMMIT과 동일하지만 실행 중인 트랜잭션 이후에 실행된 다른 트랜잭션에 의해 변경된 데이터를 SELECT할 때 항상 언두에서 값을 조회 하기 때문에 하나의 트랜잭션에서의 같은 SELECT 쿼리에 대한 값이 동일한 결과를 가져오게 해야하는 REPEATABLE READ가 보장된다. 

그러나 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상인 **PHANTOM READ**현상이 발생한다. 하지만 InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ격리 수준이라도 PHANTOM READ가 발생하지 않는다. 

### SERIALIZABLE

가장 단순한 격리 수준이면서 가장 엄격한 격리 수준으로 동시 처리 성능이 가장 떨어진다. InnoDB에서 기본적으로 순수한 SELECT작업은 아무런 레코드 잠금도 설정하지 않고 실행된다. 그러나 해당 격리 수준에선 읽기 작업도 공유 잡금을 획득해야 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
