## InnoDB 스토리지 엔진 아키텍처

InnoDB는 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금을 제공하며, 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다. 

![img1 daumcdn](https://user-images.githubusercontent.com/80368511/218774374-abf27387-442d-4060-ac87-9c2b6bb73631.png)

### **프라이머리 키에 의한 클러스터링**

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다. 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다. 따라서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 실행 계획에서 선택될 확률이 높다. 

InnoDB와 달리 ***MyISAM에서는*** 클러스터링 키를 지원하지 않는다. 프라이머리 키와 세컨더리 인덱스는 구조적으로 아무런 차이가 없으며 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다. 프라이머리 키를 포함한 모든 인덱스는 물리적은 레코드의 주소 값인 ROW ID를 가진다. 

### **외래키 지원**

외래키는 InnoDB스토리지 엔진에서만 지원하는 기능이다. 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 외래 키의 존재에 주의해야 한다. 

### **mvcc**

하나의 레코드에 대해 여러 개의 버전이 동시에 관리되며 잠금을 사용하지 않는 일관된 읽기를 제공하는 기능이다. 해당 기능은 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, InnoDB는 언두로그를 통해 이 기능을 구현한다. 

### **자동 데드락 감지**

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 종료한다. 해당 트랜잭션의 언두로그의 양을 비교해 더 적게 가진 트랜잭션이 롤백이 된다. 언두로그의 레코드의 양이 적을수록 트랜잭션 강제 롤백으로 인한 서버의 부담이 적기 때문이다. 

동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금 갯수가 많아지면 데드락 감지 스레드가 느려지며 더 많은 CPU자원을 소모해 성능에 문제가 생길 수 있는데 이럴땐 시스템 변수를 통해 자동 데드락 감지를 OFF시킬 수 있다. 

### **자동화된 장애 복구**

InnoDB에서는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 기능이 있다. 서버가 시작될 때 이전에 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다. 

### **버퍼풀**

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 또한 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.  

**구조**

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU 리스트와 플러시 리스트, 프리 리스트라는 3개의 자료 구조를 관리한다.  

- 프리 리스트 : 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이다. 상용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
- LRU 리스트 : LRU리스트를 관리하는 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것이다.
    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
    2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고 적재된 페이지에 대한 포인터를 LRU헤더에 추가. 
    3. LRU 헤더 부분에 적재된 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동.
    4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 Age가 부여되고, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화 되고 MRU페이지로 이동된다. 
    5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
    
    이러한 과정 때문에 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 버퍼 풀 MRU영역에 계속 살아남게 되고, 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 LRU끝으로 밀려나 결국 버퍼 풀에서 제거된다. 
    
- 플러시 리스트(더티페이지) : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리한다. 디스크에서 읽은 상태 그대로 전혀 변경이 없다면 플러시 리스트에서 관리되지 않지만, 데이터 변경이 가해지면 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 한다. 데이터가 변경되면 InnoDB는 변경내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영해서 리두 로그의 각 엔트리가 특정 데이터 페이지와 연결된다. 엔진은 체크포인트를 발생시켜 디스크의 리두로그와 데이터 페이지의 상태를 동기화 시킨다.

**버퍼 풀과 리두 로그**

InnoDB의 버퍼 풀 용량을 늘리면 캐시 성능은 좋아지지만 쓰기 버퍼링 기능까지 향상시키기 위해선 버퍼 풀과 리두 로그의 관계를 잘 이해해야 한다. 

버퍼 풀에는 처음 읽은 상태와 동일한 페이지인 클린 페이지와 변경된 데이터를 가진 더티 페이지가 존재한다. 더티 페이지는 언젠가 디스크로 동기화 되어야 하며 InnoDB의 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고 체크 포인트가 발생되면 체크포인트 LSN(Long Sequnce Number, 리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션이 증가 된 값을 가짐.)보다 작은 리두 로그 엔트리와 관련된 더티 페이지와 리두 로그 엔트리가 디스크로 동기화 되어야 한다.  

### Double Write Buffer

InnoDB 스토리지엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이로 인해 더티 페이지를 디스크 파일로 플러시할 때 일부분만 기록되는 문제가 발생하면 그 페이지의 내용은 복구할 수 없을 수도 있는데 이렇게 페이지 일부만 기록 되는 현상을 파셜 페이지라고 한다. 

InnoDB 스토리지 엔진은 이러한 문제를 막기 위해 Double-Write 기법을 이용한다. 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지들을 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite버퍼에 기록하고 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다. 페이지가 모두 정상적으로 데이터 파일에 기록되면 더이상 필요가 없어지고 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래의 목적으로 사용된다. 

### **언두 로그**

InnoDB 스토리지 엔진은 트랜잭션(롤백)과 격리수준을 보장하기 위해 변경되기 이전에 데이터를 백업하며 백업된 데이터를 언두 로그라고 한다. 

**언두 더블스페이스 관리**

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그만터를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다. 

### 체인지 버퍼

레코드가 INSERT, UPDATE될 때 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다. 인덱스를 변경하기 위해선 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 성능이 낮아질 수 있다. InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 디스크로부터 읽어와서 업데이트해야 한다면 체인지 버퍼라는 임시 메모리 공간을 사용해서 저장한 후 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킨다. 

결과를 반환하기 전 중복체크를 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되며 이 스레드를 체인지 버퍼 머지 스레드라고 한다. 체인지 버퍼는 기본적으로 버퍼 풀로 설정된 메모리 공간의 25% - 50%를 사용한다. 

### 리두 로그 및 로그 버퍼

리두 로그는 트랜잭션 요소 중 Durable에 관련되어있다. 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 것이다. 일관되지 않은 데이터를 가질 수 있는 조건은 커밋됐지만 데이터 파일에 저장되지 못한 데이터나, 롤백됐지만 데이터 파일에 이미 반영된 데이터가 있다. 전자의 경우 리두 로그를 통해 저장된 데이터를 데이터 파일에 반영하면 된다. 후자의 경우 변경 전 데이터를 언두 로그에서 가져와 데이너 파일에 복사하면 되지만 리두 로그를 통해 커밋 상태인지 롤백 상태인지 트랜잭션 실행 중인 상태였는지를 확인해야 한다. 

### 어뎁티브 해시 인덱스

사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB스토리지 엔진이 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다. 

B-Tree인덱스의 검색시간을 줄이기 위해 도입된 기능이다. 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다. B-Tree의 루트노드부터 리프 노드까지 찾아가는 비용이 없어지고 쿼리의 성능이 빨라지며 컴퓨터는 더 많은 쿼리를 동시에 처리할 수 있다.
