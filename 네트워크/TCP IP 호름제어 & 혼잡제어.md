### 흐름 제어 flow control

수신 노드가 전송 노드의 데이터에 제압되지 않도록 **수신자가 두 노드 간 데이터 전송속도를 제어**할 수 있는 매커니즘을 제공한다. 

### Stop And Wait

![Stop-and-Wait-ARQ-Limitation-1](https://user-images.githubusercontent.com/80368511/216670769-5629adad-8a6d-4714-864d-091d6ef07beb.png)


매번 전송에 필요한 패킷에 대한 응답(ACK)을 받으면 다음 패킷을 전송하는 방법이다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다. 

### Sliding Window

![download](https://user-images.githubusercontent.com/80368511/216670859-08fe5599-e65e-4a39-8182-2aefb83849ad.png)


수신 측에서 설정한 윈도(단위시간 내에 보내는 패킷의 수) 크기만큼 송신 측에서 확인 응답 ACK없이 패킷을 전송할 수 있게 하고, 그 패킷들의 전달이 확인되는대로 이 윈도를 옆으로 옮김으로서 그 다음 패킷들을 전송하는 방식이다. 따라서 아직 확인을 받지 않고도 여러 패킷을 보내는 것을 가능케 하기 때문에 매번 전송한 패킷에 대해 확인을 받아야만 그 다음 패킷을 전송하는 stop and wait보다 훨씬 네트워크를 효율적으로 사용할 수 있다. 

전송되는 각 패킷들에게 일련번호 sequence number가 매겨진다. 또한 송신자는 다음 세가지 변수를 관리한다.

![sliding window](https://user-images.githubusercontent.com/80368511/216670992-d8beccfc-4b1f-4940-a44c-ac1dc7171230.png)

- Send Window Size - 윈도 크기
- Last Acknowledgement Received - 마지막으로 확인받은 패킷의 번호
- Last Frame Sent - 마지막으로 보낸 패킷의 번호

송신자의 윈도는 그림처럼 *[(LAR+1), ... , (LAR+SWS)]*가 된다. 송신자는 이 윈도에 포함되는 모든 패킷들을 전송하고, 수신자로부터 ACK가 올때까지 기다린다. 아무 문제가 없다면 수신자로부터 LAR + 1의 ACK를 가장 먼저 받게 된다. 그렇다면 송신자는 LAR을 갱신하고, 그렇게 되면 LAR + SWS도 그만큼 증가하기 때문에 그 다음 패킷을 보낼 수 있게 된다.  만약 어느 패킷에 대해 ACK를 받지 못한 경우, 송신자는 일정시간을 기다린 후, 확인받지 못한 패킷을 재전송한다. 이미 현재의 윈도우에 해당되는 패킷을 모두 보냈는데, ACK를 받지 못해 윈도를 이동시키지 못하고 있다면 ACK가 오기까지 기다려야 한다. 

수신자는 다음 세가지의 변수를 관리한다.

- Receive window size - 윈도 크기
- Last Acceptable Frame - 수신할 수 있는 마지막의 패킷의 번호
- Last Frame Received - 마지막으로 수신한 패킷의 번호

수신자는 LAF, LFR의 신호를 갱신하여 윈도를 이동시키며 패킷을 접수한다. 받는 패킷의 ACK을 보내주는 것이 수신자의 역할이다. 수신자가 보내는 ACK는 마지막으로 도착한 패킷에 대한 ACK가 아니고, 연속적으로 도착한 패킷중의 가장 마지막 패킷에 대한 ACK이다. 만약 1,2,3,4,5,6,7 의 패킷이 순서대로 도착하였다면, 수신자는 그 7번의 패킷을 받아 버퍼에 저장하고, 4번의 패킷에 대한 ACK를 송신자에게 보낸다. 만약 그 다음에 도착하는 패킷이 5번이라면, 수신자는 그제서야 7번 패킷에 대한 ACK를 송신자에게 보내게 된다. 

만약 윈도에 포함되지 않는 패킷이 도착한다면, 수신자는 단순히 이 패킷을 버린다.

### 혼잡제어

데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 재전송하여 네트워크가 더욱 혼잡해지게 되는데 송신측에서 네트워크에서 처리할 패킷의 양을 조절하는 방식으로 해결한다. 

### ****합 증가 / 곱 감소 AIMD (Additive Increse/Multicative Decrease)****

![5DKJ2IU (1)](https://user-images.githubusercontent.com/80368511/216672154-4893357d-68af-4253-b80e-7a868dda107e.png)

처음 패킷을 하나씩 보내고 문제없이 도착하면 단위 시간 내에 보내는 패킷의 수를 1씩 증가시켜가면서 전송하는 방법이다. 만약 패킷 전송을 실패하거나 
일정한 시간이 넘으면 패킷을 보내는 속도를 절반으로 줄이게 된다. 

- 장점 : 이 방식은 공평한 방식으로 만약 여러 호스트가 한 네트워크를 공유하고 있으면 처음에는 진입하는 쪽이 불리하지만, 시간이 흐르면 비슷한 
데이터 양을 유지하게 된다는 특징이 있다.
- 단점 : 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 
이 방식은 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

### 느린 시작

![slow start](https://user-images.githubusercontent.com/80368511/216672786-966ff938-70d8-42a6-92fb-c90a97961c47.png)


AIMD 같은 경우 처음 전송속도를 올리는데에 시간이 오래걸린다는 단점이 있었는데 느린 시작 같은 경우 AIMD처럼 패킷을 하나씩 보내면서 시작한다. 
그러나 이 방식은 패킷이 문제 없이 도착하면 각 ACK패킷마다 창 크기를 1씩 늘린다. 
따라서 한 주기가 지나면 창 크기가 2배가 되므로 AIMD와 다르게 지수 함수 처럼 증가한다. 또한 혼잡 현상이 발생하면 창 크기를 1로 떨어 뜨린다. 
그 후 부턴 완만하게 1씩 증가시킨다. 처음 네트워크 수용량을 예상할 수 있는 정보가 없지만 한번 혼잡 현상이 발생하면 네트워크의 수용량이 
어느 정도로 예상이 가능하다. 

창 크기를 1에서부터 시작하여 지수함수 꼴로 증가시켜 네트워크 수용량을 감지하는 느린시작은 초기 TCP 동작에서 처음에 최대한 보낼 수 있는 만큼의 패킷을 
보내는 것으로 시작하는 것과 비교된다. 합 증가 / 곱 감소 방식보다 효율적이지만 마찬가지로 혼잡한 상황이 되기 전까지 네트워크 수용량을 확인 할 수 없다. 

### ****빠른 재전송 Fast Retransmit****

![images_mu1616_post_878686ca-8073-420d-8e63-6afc79622f5d_image](https://user-images.githubusercontent.com/80368511/216673118-92f61525-4769-4764-954d-8c63bf05547d.png)

패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK패킷을 보낸다. 
단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 따라서 중간에 패킷하나가 손실되게 되면 보내는 측에서는 
순번이 중복된 ACK 패킷을 받게 되고, 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송해 줄 수 있다. 
중복된 순번의 패킷을 3개 받으면 재전송을 한다. 이때, 혼잡을 감지하여 창 크기를 줄이게 된다.

### ****빠른 회복Fast Recovery****

혼잡한 상태가 되면 창 크기를1로 줄이지 않고 반으로 줄여 선형 증가시키는 방법이다. 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 합 증가/곱 감소 방식으로 동작한다.
