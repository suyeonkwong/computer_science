## Array & LinkedList

### Array

- 의미 : Array는 연관된 data를  메모리상에 연속적이며 순차적으로 미리 할당된 크기만큼 저장하는 자료구조이다.
- 장점 : Array는 조회와 저장이 빠르다. 그리므로 조회가 자주 이루어지는 작업에서 사용하는것이 좋다.
- 단점 : Array는 고정사이즈이기 때문에 선언 시 크기를 미리 지정해야 하고 이로 인해 메모리 낭비나 추가적인 overheand가 발생할 수 있다.
- 시간복잡도 : 모든 데이터의 access나 append, 마지막 원소의 delete는 O(1)의 시간 복잡도를 가지지만 중간 요소 삽입, 삭제, 검색은 O(n)의 시간 복잡도를 가진다.
  
### Linked List

- 의미 : Linked List는 Node라는 구조체로 이루어져 있는데, Node는 데이터 값과 다음 Node의 address를 저장한다. 
Linked List는 **물리적인 메모리상에서는 비연속적**으로 저장이되지만 Linked List를 구성하는 **각각의 Node가 next Node의 address를 가리킴으로써 논리적인 연속성**을 
가진 자료구조이다.
- 장점 : 메모리상에서는 불연속적으로 데이터가 저장되지만, Node의 next Address를 통해 불연속적인 데이터를 연결하여 논리적 연속성을 보장한다. 
또한 데이터가 추가 되는 시점에서 메모리를 할당하기 때문에 메모리를 좀더 효율적으로 사용할 수 있다.
- 논리적 연속성 : 각 Node들은 next Address정보를 가지고 있기 때문에 논리적으로 연속성을 유지하면서 연결되어 있다. 
Array의 경우 연속성을 유지하기 위해 물리적 메모리 상에서 순차적으로 저장하는 방법을 사용하였으며, 
Linked List의 경우 메모리에서 연속성을 유지하지 않아도 되기때문에 메모리 사용이 자유로운 대신, Next Address를 추가적으로 저장해야하기때문에 하나당 
차지하는 메모리가 더 커지게 된다.
- 시간복잡도 : Array의 경우 중간에 데이터를 삽입/삭제하게 되면 해당 인덱스 뒤에 있는 모든 원소들을 shift해야 한다. 그러므로 O(n)의 시간복잡도를 가진다. 그러나 Linked List는 물리적으로 옮길 필요가 없고 next Address를 가리키는 주소를 변경하면 되기 때문에 O(1)의 시간복잡도로 삽입/삭제가 가능하다.
    
### Array vs Linked List를 비교 요약

- 결론: Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조이다. Linked List는 메모리상에서는 연속적이지 않지만, 
각각의 원소가 다음 원소의 메모리 주소값을 저장해 놓음으로써 논리적 연속성을 유지한다. 따라서 각각의 연산의 시간복잡도가 다르다. 
데이터 조회는 Array의 경우 O(1), Linked list의 경우 O(n)의 시간복잡도를 가진다. 삽입/삭제의 경우 Array는 O(n), Linked List는 O(1)의 시간복잡도를 가진다. 
결론은 얼마만큼의 데이터를 저정할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는것이 좋고, 몇개의 데이터를 저장할 지 불확실하고 삽입/삭제가 자주 일어난다면 
Linked List를 사용하는것이 유리하다.
- 조회 : Array는 메모리상에서 연속적으로 데이터를 저장하였기 때문에 저장된 데이터에 즉시접근 할 수 있다. 
그러나 Linked List의 경우 메모리 상에서 불연속적으로 데이터를 저장하기 때문에 순차접근만 가능하다. 따라서 특정 index의 데이터를 조회하기 위해 O(n)의 시간이 걸린다.
- 삽입/삭제 : Array의 경우 마지막 원소의 추가/삭제 시 시간복잡도가 O(1)이다. 하지만 맨 마지막 원소가 아닌 중간 원소의 삽입/삭제가 일어날 경우 해당 원소보다 
큰 인덱스의 원소들을 한칸씩 shift해야 하는 비용이 발생한다. 따라서 시간복잡도가 O(n)이 된다. Linked List는 어느 원소를 추가/삭제 하더라도 
node에 다음 주소를 가리키는 부분만 변경하면 되기 때문에 shift할 필요가 없어서 시간복잡도가 O(1)이다. 
하지만 Linked List의 경우 추가/삭제를 하려는 index까지 도달하는 시간이 O(n)이기 때문에, 실질적으로 Linked List의 추가/삭제 시에 O(n)의 시간이 걸린다.
- memory : Array의 주된 장점은 데이터 접근과 append가 빠르지만 배열 선언시 고정된 크기를 설정하여 메모리를 할당받기 때문에 데이터가 저장되어 있지 않더라도 
메모리를 차지하고 있어 메모리 낭비가 발생한다. 그러나 Linked List는 runtime중에서 size를 늘리고 줄일 수 있기 때문에 초기 사이즈를 고밀할 필요가 없고, 
필요한 만큼 메모리를 할당하여 메모리 낭비가 없다. Array는 Complie단계에서 메모리 할당이 일어난다. 
이것을 Static Memory Allocation이라고 하며 Stack영역에 할당된다. Linked List의 경우 runtime단계에서 새로운 node가 추가 될때 메모리 할당이 이루어지며 
이것을 Dynamic Memory Allocation이라고 부른다. 또한 Heap영역에 메모리가 할당된다.

### ArrayList vs LinkedList

일반 배열과 ArrayList는 인덱스로 객체를 관리하여 물리적인 연속성을 가지지만, ArrayList는 크기를 동적으로 늘릴 수 있다. 
처음 설정한 저장용량(capacity)을 설정한 저장 용량 크기를 넘겨 더 많은 데이터가 들어오게 되면 내부적으로 배열 크기를 1.5배 증가시킨다. 

- ArrayList도 중간에 요소가 삽입 or 삭제될 경우 물리적 연속성을 위해 요소의 shift과정이 필요하므로 O(n)의 시간복잡도를 가진다. 
조회는 O(1)의 시간복잡도를 가진다. LinkedList의 경우 삽입 or 삭제 시 nextAddress의 값만 변경하면 되므로 O(1)의 시간복잡도를 가진다. 
조회는 모든 Node를 탐색해야하므로 O(n)의 시간복잡도를 가진다.

**데이터 조회, 순차적 삽입/삭제가 잦다면 ArrayList를 중간 요소 삽입/삭제가 잦다면 LinkedList를 사용하자.**
